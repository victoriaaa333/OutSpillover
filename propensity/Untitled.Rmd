---
title: "tmp-propensity"
author: "Yihan Bao yb254"
date: "4/6/2023"
output: html_document
---
```{r}
setwd("~/Desktop/out-spillover")
source("utils/weight_matrix.R")
source("point_estimates/point_estimates.R")
source("utils/integrand.R")
source("utils/utils.R")
source("variances/bootstrap_variance.R")
source("variances/m_variance.R")
source("variances/regression_variance.R")
source("variances/regression_utils.R")
source("variances/regression_utils_neigh.R")
source("utils/mixed_effects.R")
source("propensity/propensity.R")
library(igraph)
library(lme4)

source("propensity/propensity_effect_calc.R")
```
```{r}

```

## Generate the dataset
```{r}
# 0.1 first generating the model for spillover effect

##########
  #1. Generate a graph and dataset (treatments, covariates)
  graph = make_empty_graph(n = 0, directed = FALSE)
  repeat{
    g2 = sample_gnp(20, 0.5, directed = FALSE, loops = FALSE)
    graph = disjoint_union(graph, g2)
    if (clusters(graph)$no == 10){
      break}
  }
  G = group_vector(graph) 
  
  numerator_alpha = 0.5
  denominator_alphas = c(0.4,0.6)
  P = c(0.5,0.5) 
  P_1 = sample(c(1,2), length(unique(G)), replace = TRUE, prob = P)
  P_1 = sapply(G, function(x) P_1[x])
  P_2 = rep(NA, length(P_1))
  A = rep(NA, length(P_1))
  for (i in 1:length(P_1)) {
    P_2[i] = denominator_alphas[P_1[i]]
    A[i] = sample(c(0,1), 1, prob = c(1-P_2[i],P_2[i]))
  }
  
  G_mat = as.matrix(G)
  X1 <- sample(c("M", "F"), size = length(A), replace = TRUE)
  X2 <- rnorm(length(A),mean = 0.5, sd = 1)
  
  X <- cbind(X1, X2)
  X_type <- c("C", "N")
  x0 <- as.matrix(c("M", 1))
  x1 <- x0
  x1_num <- c(1)
  
  X_num <- apply(as.matrix(X[, X_type == "N"]), 2, as.numeric)
  X_cat <- as.matrix(X[, X_type == "C"])
  
  df <- cbind.data.frame(A,G,X)
  df$treated_neigh <- h_neighsum(graph, A, 1) 
  df$interaction1 <-  ifelse(X_cat[,1] == "M", 1, 0)  * df$treated_neigh
  df$interaction2 <- X_num[,1] * df$treated_neigh
  
  ##########
  # 2. Outcome model
  aa = 2; bb = 5; cc = 7; dd = 9
  Y = apply(cbind(df$A, df$treated_neigh, df$interaction1, df$interaction2), 1, #X_num,
            function(x)  rnorm(1, mean = aa*x[1] + bb*x[2] + cc*x[3] + dd*x[4], sd = 1))  
  H = h_neighborhood(graph, Y, 1) 
  H_M =  h_neighborhood(graph, Y, 1, X_cat, c("M")) 
  df$Y = Y
  df$H = H
  df$H_M = H_M
  
  # 2.1 neighinfo
  neighX = h_neighcov(graph, 1, X, X_type, x1) # average of X for unit j's 1-order neighbor
  neighinfo = list(neighX)
  names(neighinfo) <- c('neighX')

```

```{r}
# let's only consider the numerical case for now, the categorical case needs a revision on logit_integrand potentially

formula <- H | A  ~ X2 + (1|G) | G
parameters <- unlist(propensity_parameter(formula, df)[1])

allocations = list(c(0.5,denominator_alphas))

w.matrix = wght_matrix(integrand =logit_integrand, 
                        allocations, 
                        G, A, P,
                        X = cbind(X2), 
                        parameters = parameters,
                        randomization = 1,
                        integrate_allocation = TRUE,
                        runSilent = TRUE)

point_estimates <- ipw_point_estimates_mixed_test4(H, G, A, w.matrix, 
                                                    X = X, x0 = x0, 
                                                    X_type = X_type,
                                                    Con_type = "group")

```

```{r}
obj <- list(weights = weights, point_estimates = point_estimates)
ipw_point_estimates <- ipw_point_estimates_mixed_test4
variance_estimation <- "robust"
alpha1 = allocations[1]
trt.lvl1 = 1
alpha2 = NA
trt.lvl2 = NA
effect_type = 'constrast'
marginal = FALSE
rescale.factor = 1
conf.level = 0.95
print = FALSE

#U_args     <- append(estimate_args, list(weights = weightd))
```

```{r}
dots <- list()
integrand_args <- get_args(FUN = logit_integrand, args_list = dots)
point_est_args <- get_args(FUN = ipw_point_estimates, args_list = dots)  
loglihood_args <- get_args(FUN = loglihood_integrand, args_list = dots)
grad_args      <- get_args(FUN = numDeriv::grad, args_list = dots)
integrate_args <- get_args(FUN = stats::integrate, args_list = dots)

weight_args <- append(append(integrand_args, integrate_args),
                        list(integrand   = propensity_integrand, 
                             allocations = allocations, 
                             X = as.matrix(X2), A = A, G = G,
                             parameters = c(1, 1, 0),
                             runSilent  = TRUE, #BB 2015-06-23
                             integrate_allocation = TRUE
                             ))

```




```{r}
 allocations <- dimnames(obj$weights)[[2]] 
  
  ## Warnings ##
  # Print error if either estimates with alpha1 have been computed 
  # or a constrast is being estimated when estimates for alpha2
  # have not been computed
  if (!(alpha1 %in% allocations) | (effect_type == 'contrast' & !(alpha2 %in% allocations))){
    stop(paste('At least one of the chosen coverage levels has not been estimated.\n',
               'Select from the following: \n', 
               paste(allocations, collapse = ' ')))
  }
  
  ## Necessary bits ##
  N  <- dim(obj$weights)[1] 
  p  <- dim(obj$scores)[2] 
  k  <- length(allocations)
  l  <- dim(obj$point_estimates$outcomes$overall)[2]
  a1 <- as.character(alpha1)
  a2 <- as.character(alpha2)
  t1 <- as.character(trt.lvl1)
  t2 <- as.character(trt.lvl2)
  
  fff <- ifelse(marginal == TRUE, 'marginal_outcomes', 'outcomes')
  
  oal  <- obj$point_estimates[[fff]]$overall
  grp  <- obj$point_estimates[[fff]]$groups
  
  if(variance_estimation == 'robust'){
    Uoal <- obj$Upart[[fff]]$overall 
    Ugrp <- obj$Upart[[fff]]$groups
    
    # Cludgy workaround for case of 1 fixed effect: add dimension to Ugrp array #
    if(p == 1){
      names <- dimnames(Ugrp)
      if(marginal == TRUE){
        Ugrp <-  array(c(Ugrp[1:N, ], 1, Ugrp[, 1:k]),
                       dim=c(N, 1, k),
                       dimnames = list(names[[1]], 'Intercept', names[[2]]))
      } else {
        Ugrp <-  array(c(Ugrp[1:N, , ], 1, Ugrp[, 1:k , 1:l]),
                       dim=c(N, 1, k, l),
                       dimnames = list(names[[1]], 'Intercept', names[[2]], names[[3]]))
      }
    }
  }
  
  if(effect_type == 'contrast'){
    if(marginal == TRUE){
      pe          <- oal[a1] - oal[a2]
      pe_grp_diff <- (grp[ , a1] - oal[a1]) - (grp[, a2] - oal[a2])
      if(variance_estimation == 'robust'){
        U_pe_grp    <- Ugrp[ , , a1] - Ugrp[ , , a2]
      }
    } else {
      pe          <- oal[a1, t1] - oal[a2, t2]
      pe_grp_diff <- (grp[ , a1, t1] - oal[a1, t1]) - (grp[ , a2, t2] - oal[a2, t2])
      if(variance_estimation == 'robust'){
        U_pe_grp    <- Ugrp[ , , a1, t1] - Ugrp[ , , a2, t2]
      }
    }
  } else {
    if(marginal == TRUE){
      pe          <- oal[a1] 
      pe_grp_diff <- (grp[ , a1] - oal[a1])
      if(variance_estimation == 'robust'){
        U_pe_grp    <- Ugrp[ , , a1]
      }
    } else {
      pe          <- oal[a1, t1] 
      pe_grp_diff <- (grp[ , a1, t1] - oal[a1, t1])
      if(variance_estimation == 'robust'){
        U_pe_grp    <- Ugrp[ , , a1, t1]
      }
    }
  }
  
  #### VARIANCE ESTIMATION ####
  if(variance_estimation == 'robust'){
    # partial U matrix
    if(p == 1){
      U21 <- sum(-U_pe_grp)/N
    } else {
      U21 <- (t(as.matrix(apply(-U_pe_grp, 2, sum, na.rm = T))))/N
    }
    
    # V matrix
    V <- V_matrix(scores = obj$scores, 
                  point_estimates = obj$point_estimates, 
                  allocation1 = a1, allocation2 = a2, 
                  trt.lvl1 = t1, trt.lvl2 = t2, 
                  effect_type = effect_type, marginal = marginal)
    
    vdim <- dim(V)[1]
    
    V21 <- V[vdim, 1:(vdim - 1)] # Last row, up to last column
    V11 <- V[1:(vdim - 1), 1:(vdim - 1)] # up to last row, up to last column
    V22 <- V[vdim, vdim] # bottom right element
    
    ## Sandwich Variance Estimate ##
    ave <- ((U21 - 2*V21) %*% solve(V11) %*% t(U21) + V22)/N * rescale.factor^2
  } else if(variance_estimation == 'naive'){
    ave <- (1/(N^2)) * (sum((pe_grp_diff)^2, na.rm = T)) * rescale.factor^2
  }
```

